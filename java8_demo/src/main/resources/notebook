1. HashMap

JDK8之前：在HashMap调用构造方法的时候，就会在底层创建一个长度为16的Entry[] table数组 ，采用链表解决hash碰撞
JDK8之后：在第一次调用put()方法的时候，才创建长度为16的Node[] table数组，采用链表+红黑树解决hash碰撞

map.put("hello","world");
1.调用key所在类中重写的hashCode()方法计算出"hello"对应的哈希值，然后结合数组长度，采用某种算法计算出向Node数组中存储数据的空间的索引值：
      如果该索引空间没有数据，则直接将数据存储到该索引空间；
      如果该空间有数据，则比较两者的hashCode值是否一值：
            如果不一致，则在该索引空间上划分出一个节点存储新的节点（拉链法）
            如果一致，则发生hash碰撞，调用key所在类中重写的equals()方法，比较两者key是否是真的相等：
                  如果不相等，则在该索引空间上划分出一个节点存储新的节点
                  如果相等，则说明两者key是同一个key，那么就将后者的value去覆盖前者key的value值
2.如果链表长度大于8，并且数组长度大于64，则将链表转化成红黑树，如果也就是红黑树，则调用红黑树的插入方法

HashMap底层计算hashCode值的方法：采用key的hashCode()方法的值，结合数组长度进行无符号右移(>>>)、按位异或(^)、按位与(&) 计算出索引
还可以采用：平方取中法、取余数法、伪随机数法（这三种方法计算效率较低）

当链表长度大于8，并且数组长度大于64的时候，链表才会转化成红黑树；当链表长度小于6的时候，红黑树就会变成链表
按位或运算（ | ）：相同数位上都是0的时候为0，否则为1
按位与运算（&）：相同数位上都是1的时候为1，否则为0
按位异或运算(^) ：相同数位上数字相等的时为0，否则为1
hash & (length - 1)  ==> hash % length

Map<String, Integer> map = new HashMap<>(8);
初始化数组容量必须是2的n次幂（减少hash碰撞）
hash & (table.length() - 1) 按位与计算索引（都是1的时候才为1）
假设hash为3  二进制      00000011
length-1 = 7                 00000111
按位与计算索引为3         00000011

假设hash为2  二进制      00000010
length-1 = 7                 00000111
按位与计算索引为2         00000010

如果初始化容量为9，不是2的n次幂，及其容易发生hash碰撞：
假设hash为3  二进制    00000011
length-1 = 8               00000100
按位与计算索引为0       00000000

假设hash为2 二进制     00000010
length-1 = 8               00000100
按位与计算索引为0       00000000        发生hash碰撞
导致数组其余空间大面积没有存储数据，许多数据都堆积到一条链表上

static final int MAXIMUM_CAPACITY = 1 << 30;

static final int tableSizeFor(int cap) {
        int n = cap - 1;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;
}

假如初始化容量给的不是2的n次幂，在底层则会通过按位或运算和无符号右移运算将容量转化成大于给定的容量值的最小2的n次幂容量；

Map<String, Integer> map = new HashMap<>(10);
cap = 10
n = 10 - 1 = 9
00000000 00000000 00000000 00001001      9
00000000 00000000 00000000 00000100      9 >>> 1 = 4
00000000 00000000 00000000 00001101      13
n = 13
00000000 00000000 00000000 00001101      13
00000000 00000000 00000000 00000011      13 >>> 2 = 3
00000000 00000000 00000000 00001111      15
n = 15
00000000 00000000 00000000 00001111       15
00000000 00000000 00000000 00000000       15 >>> 4 = 0
00000000 00000000 00000000 00001111       15
n = 15
00000000 00000000 00000000 00001111       15
00000000 00000000 00000000 00000000       15 >>> 8 = 0
00000000 00000000 00000000 00001111       15
n = 15
00000000 00000000 00000000 00001111       15
00000000 00000000 00000000 00000000       15 >>> 16 = 0
00000000 00000000 00000000 00001111       15

return 16;

size字段记录的是key-value键值对的个数，初始值为0，调用size()方法返回的则是map中真实存在的key-value键值对个数，
size的值并不是初始化容量指定的值

float ft = ((float)s / loadFactor) + 1.0F;
加1.0F 获得更大的容量，减少调用resize()扩容
调用resize()方法进行扩容的时候容量变成之前的两倍，与原来计算的（n -1）& hash 结果相比，只是多了一个bit位，
所以节点要么在原来索引的位置，要么被分配在原来位置+旧的容量的索引位置，有效的避免了重新计算hash索引

红黑树平均查找长度为 log(n)
链表平均查找长度为    n / 2

2.Java反射：
对于java.lang.Class类的理解：
1.类的加载过程：
    程序经过javac.exe命令以后，会生成一个或多个字节码文件（.class文件）。接着我们使用java.exe命令对某个字节码文件进行解释运行。
相当于将某个字节码文件加载到内存中。此过程就称为类的加载。加载到内存中的类，我们就称为运行时类，此运行时类就作为Class的一个实例。
2.Class的实例就对应着一个运行时类， 加载到内存中的运行时类会缓存一段时间。在此时间内，我们可以通过不同方式来获取此运行时类。
3.获取Class实例的方法：
方式一：通过运行时类的属性: .class
方式二：通过运行时类的对象：getClass()
方式三：调用Class类的静态方法：forName(String classPath)
方式四：使用类的加载器：ClassLoader

getFields: 只能获取public修饰的属性
declaredFields ：可以获取所有属性   ----->   name.setAccessible(true);  保证对象属性可访问，否则会跑非法访问异常


函数式接口：只有一个抽象方法的接口(不能出现第二个方法)

消费性接口 Consumer<T>   void accept(T t)
供给型接口 Supplier<T>   T get()
函数型接口 Function<T,R> R apply(T t)
断定型接口 Predicate<T>  boolean test(T t)

